In Assignment 2, my ETL pipeline was functional but followed a procedural structure that lacked object-oriented design. All logic, including file I/O, CSV parsing, data transformation, and error handling, was consolidated within a single class and one main method. This does not demonstrate strong object-oriented design, making the system difficult to maintain and scale as there was no clear separation of tasks.

For Assignment 3, I redesigned the solution to be more object-oriented with the help of generative AI. I broke the logic into multiple classes with distinct responsibilities: Product, ProductExtractor, ProductTransformer, ProductLoader, ETLPipeline, and a Transformer<T> interface. This redesign separates the extract, transform, and load stages into independent components, making the system more organized and easier to understand.

One major difference between Assignment 2 and Assignment 3 is the introduction of a domain object. In Assignment 2, each row from the CSV file was processed using primitive types and temporary variables. In Assignment 3, I created a Product class to represent each product record. This demonstrates the object concept by modeling real-world data as an object with attributes such as productId, name, price, category, and priceRange. The Product class encapsulates these fields using private variables and public getter methods, demonstrating encapsulation. Once created, a Product object cannot be modified, which improves clarity and reduces unintended side effects. 

Another major improvement is the separation of concerns. In Assignment 3, the ProductExtractor class is responsible only for reading and validating input data. The ProductTransformer class applies business rules such as the Electronics discount, rounding logic, category updates, and price range determination. The ProductLoader class handles writing the transformed data to the output file. The ETLPipeline class coordinates these components. This decomposition improves cohesion within each class and reduces dependency between components.

Assignment 3 introduces polymorphism through the Transformer<T> interface. The ProductTransformer class implements this interface and provides its own version of the transform method. The ETLPipeline uses the Transformer<Product> type instead of directly depending on the ProductTransformer class, meaning the pipeline relies on a general abstraction rather than a specific implementation. As a result, different transformer implementations could be added in the future without changing the pipelineâ€™s structure. For example, a HolidayProductTransformer could apply a 15% discount to all products during a seasonal promotion, and the pipeline would not need to be modified: only the transformer instance would change.

To verify that Assignment 3 produces the same behavior as Assignment 2, I performed several tests. I ran both versions using the sample input file from Assignment 2 and compared the generated transformed_products.csv files to confirm they were identical. I also tested the case where the input file does not exist to ensure the same error message was printed and the program exited cleanly. In addition, I tested an empty input file and a file containing only a header row to confirm the program handled these cases correctly. I reran the program multiple times to ensure consistent output and verified that the file was written to the correct relative path.

Overall, Assignment 3 demonstrates a clear shift to a more object-oriented approach. By introducing classes with specific responsibilities, encapsulating data within objects, and implementing polymorphism through an interface, the system is more modular and easier to maintain. At the same time, I ensured that all functionality, input/output behavior, and error handling remained identical to Assignment 2, as required.
